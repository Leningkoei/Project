# OS

## 操作系统的基本概念

### 操作系统的概念

* 操作系统的特征
    * 并发(最基本)
    * 共享(最基本)
        * 互斥访问方式
        * 同时访问方式
    * 虚拟
    * 异步

* 操作系统的目标和功能
    * 操作系统作为计算机系统资源的管理者
        * 处理机管理
        * 存储器管理
        * 文件管理
        * 设备管理
    * 操作系统作为用户与计算机硬件系统之间的接口
        * 命令接口
        * 程序接口
    * 操作系统用作扩充机器

* ---

* 操作系统提供给编程人员的接口是<u>系统调用</u>

* <u>顺序性</u>不属于多道程序设计的基本特征

* 说明库函数与系统调用的区别和联系
    * 库函数
        * 库函数是语言或应用程序的一部分, 可以运行在用户空间中
    * 系统调用
        * 系统调用是操作系统的一部分, 是内核为用户提供的程序接口, 运行在内核空间中
    * 联系
        * 许多库函数都会使用系统调用来实现功能
        * 未使用系统调用的库函数, 其执行效率通常比使用了系统调用的库函数高, 因为在使用系统调用时需要进行上下文的切换以及状态的转换(由用户态转向核心态)

### 操作系统的发展与分类

* 手工操作阶段

* 批处理阶段
    * 单道批处理系统
        * 自动性
        * 顺序性
        * 单道性
    * 多道批处理系统
        * 多道
        * 宏观上并行
        * 微观上串行
        * [x] 资源利用率高
        * [x] 系统吞吐量大
        * [ ] 用户响应时间长
        * [ ] 不提供人机交互能力
* 分时操作系统
    * 同时性
    * 交互性
    * 独立性
    * 及时性

* 实时操作系统
    * 硬实时系统
    * 软实时系统

* 网络操作系统和分布式计算机系统

* 个人计算机操作系统

* ---

* 实时系统的进程调度, 通常采用<u>抢占式的优先级高者优先</u>算法

* 分时系统追求的目标是<u>比较快速响应用户</u>

* 批处理操作系统, 分时操作系统, 实时操作系统各有什么特点
    * 批处理操作系统的用户脱机使用计算机, 作业时成批处理的, 系统内多道程序并发执行, 交互能力差
    * 分时操作系统可让多个用户同时使用计算机, 人机交互性较强, 具有每个用户独立使用计算机的独占性, 系统响应及时
    * 实时操作系统能对控制对象做出及时反应, 可靠性高, 响应及时, 但资源利用率低

### 操作系统的运行环境

* 操作系统的运行机制
    * 时钟管理
    * 中断机制
    * 原语
        * 最底层, 最接近硬件
        * 原子性
        * 运行时间短, 调用频繁
    * 系统控制的数据结构及处理
        * 进程管理
        * 存储器管理
        * 设备管理

* 中断和异常的概念
    * 用户态转向核心态的门
    * 内中断和外中断的联系与区别
        * 内中断(异常)
            * 自愿中断
                * 指令中断
            * 强迫中断
                * 故障中断
                * 软件中断
        * 外中断(中断)
            * 强迫中断
                * 外设请求
                * 人的干预
    * 中断处理的过程:
        关中断 -> 保存断点 -> 引出中断服务程序 -> 保存现场和屏蔽字 ->
        开中断 -> 执行中断服务程序 -> 关中断 -> 恢复现场和屏蔽字 -> 开中断, 中断返回

* 系统调用
    * 类别
        * 设备管理
        * 文件管理
        * 进程控制
        * 进程通信
        * 内存管理
    * 用户态转向核心态的过程:
        用户进程执行 -> 调用系统调用 -(陷阱)> 执行系统调用 -(返回)>从系统调用返回
    * 用户态转向核心态的例子
        * 用户程序要求操作系统的服务
        * 发生1次中断
        * 用户程序中产生了1个错误状态
        * 用户程序中企图执行1条特权指令
        * 从核心态转向用户态由1条指令实现, 这条指令也是特权指令, 一般是中断返回指令
    * 访管指令: 程序的运行从用户态转到核心态时会用到

* ---

* 处理器为什么要区分核心态和用户态2种操作方式? 在什么情况下进行2种方式的切换?
    * 区分执行态的目的是保护系统程序
    * 用户态到核心态的转换发生在中断产生时
    * 核心态到用户态的转化发生在中断返回程序时

### 操作系统的体系结构

* 大内核
    * [x] 高性能
    * [ ] 内核代码庞大
    * [ ] 结构混乱
    * [ ] 难以维护

* 微内核
    * [x] 内核功能少
    * [x] 结构清晰
    * [x] 方便维护
    * [ ] 需要频繁地在核心态和用户态之间切换, 性能低

## 进程管理

### 进程与线程

* 进程的概念和特征
    * 进程的概念
        * 进程是程序的1次执行过程
        * 进程是1个程序及其数据在处理机上顺序执行时所发生的活动
        * 进程是具有独立功能的程序在1个数据集合上运行的过程, 它是系统进行资源分配和调度的1个独立单位
    * 进程的特征
        * 动态性
        * 并发性
        * 独立性
        * 异步性
        * 结构性

* 进程的状态与转换
    * 5种进程状态
        * 运行态
        * 就绪态
        * 阻塞态
        * 创建态
        * 结束态
    * 5种进程状态的转换
        * <image src="./images/5种进程状态的转换.jpg" />
        * 就绪态 -> 运行态: 就绪态进程被调度获得处理机资源
        * 运行态 -> 就绪态:
            运行态进程时间片用完让出处理机,
            可剥夺系统中有更高优先级进程进入
        * 运行态 -> 阻塞态: 运行态进程请求资源或等待某1事件的发生
        * 阻塞态 -> 就绪态: 阻塞态进程等待的事件到来

* 进程控制
    * 进程的创建
        * 为新进程分配1个唯一的进程标识号, 并申请1个空白的PCB
        * 为进程分配资源
        * 初始化PCB
        * 进入就绪队列
    * 进程的终止
        * 触发条件
            * 正常结束
            * 异常结束
            * 外界干预
        * 过程(撤销原语)
            * 根据被终止进程的标识符, 检索PCB, 从中读出该进程的状态
            * 若被终止进程处于执行状态, 立即终止该进程的执行, 将处理机资源分配给其他进程
            * 若该进程还有子孙进程, 则终止其所有子孙进程
            * 归还该进程的所有资源给父进程或操作系统
            * 删除PCB
    * 进程的阻塞和唤醒
        * 阻塞过程(阻塞原语)
            * 找到进程号对应PCB
            * 若该进程为运行态, 则保护该现场, 转为阻塞态
            * 把该PCB插入相应事件的等待队列, 将处理机资源调度给其他就绪进程
        * 唤醒过程(唤醒原语)
            * 在该事件的等待队列中找到相应进程的PCB
            * 将其从等待队列中移出, 转为就绪态
            * 把PCB插入就绪队列, 等待调度程序调度
    * 进程切换: 处理机从1个进程的运行转到另1个进程上运行
        * 保存处理机上下文, 包括程序计数器和其他寄存器
        * 更新PCB信息
        * 把进程的PCB移入相应的队列
        * 选择另1个进程执行, 并更新其PCB
        * 更新内存管理的数据结构
        * 恢复处理机上下文

* 进程的组织(进程的组成)
    * 进程控制块(PCB)
        * 进程描述信息
        * 进程控制和管理信息
        * 资源分配清单
        * 处理机相关信息
    * 程序段(正文段)
        * 2进制代码和常量
    * 数据段
        * 数据堆段
            * 动态分配的存储区
        * 数据栈段
            * 临时使用的变量

* 进程的通信
    * 共享存储
    * 消息传递: 发送消息原语, 传递消息原语
        * 直接通信方式
        * 间接通信方式
    * 管道通信: pipe文件连接2个进程

* 线程概念和多线程模型
    * 线程的基本概念
        * 轻量级的进程
        * 基本的CPU执行单元, 程序执行流的最小单元
        * 线程ID, 程序计数器, 寄存器集合, 堆栈
        * 进程中的1个实体, 被系统独立调度和分派的基本单位
        * 不拥有系统资源, 与其他同属1个进程的线程s共享进程资源
        * 就绪, 阻塞, 运行3中状态
        * 线程作为CPU资源的分配单元, 进程作为其他资源的分配单元
    * 线程与进程的比较
        * 调度
        * 拥有资源
        * 并发性
        * 系统开销
        * 地址空间和其他资源
        * 通信方面
    * 线程的属性
        * 轻量级的实体, 不拥有系统资源, 有唯一标识符和线程控制块, 线程控制块记录线程执行的寄存器, 栈等现场状态
        * 不同的线程可以执行相同的程序
        * 同一进程中的各个线程共享该进程所拥有的资源
        * 线程是处理机的独立调度单位, 多个线程可以并发执行
    * 线程的实现方式
        * 用户级线程
        * 内核级线程
    * 多线程模型
        * 多对1模型
        * 1对1模型
        * 多对多模型

* ---

* 进程和程序之间可以形成1对1, 1对多, 多对1, 多对多的关系, 请分别举例说明在什么情况下会形成这样的关系
    * 1对1: 执行1条命令或运行1个应用程序时
    * 1对多: 进程在执行过程中可以加载执行不同的应用程序
    * 多对1: 以不同参数或数据多次执行同1个应用程序
    * 多对多: 并发地执行不同的应用程序

* 父进程创建子进程和主程序调用子程序有何不同?
    * 父进程创建子进程后与子进程同时执行(并发)
    * 主程序调用子程序后, 主程序暂时停在调用点, 子程序开始执行, 直到子程序返回, 主程序才继续执行

* 为什么进程之间通信必须借助于操作系统内核功能? 简单说明进程通信的几种主要方式
    * 每个进程都有自己独立的地址空间, 在操作系统和硬件的地址保护机制下, 进程无法访问其他进程的地址空间, 所以必须借助操作系统的系统调用函数实现进程之间的通信
    * 共享内存区, 消息传递, 管道系统, 共享文件

* 什么是多线程? 多线程与多任务有什么区别?
    * 多线程是指在1个程序中可以定义多个线程并同时运行它们, 每个线程可以执行不同的任务
    * 多任务是针对操作系统而言的, 代表操作系统可以同时执行的程序个数
    * 多线程是针对1个程序而言的, 代表1个程序可以同时执行的线程个数, 而每个线程可以完成不同的任务

* 现代操作系统一般都提供多进程(或称多任务)运行环境, 回答以下问题:
    为支持多进程的并发执行, 系统必须建立哪些关于进程的数据结构?
    为支持进程状态的变迁, 系统至少应提供哪些进程控制原语?
    执行每个进程控制原语时, 进程状态发生什么变化? 相应的数据结构发生什么变化?

    * 进程控制块(PCB)
    * 创建新进程原语: 从PCB集合中申请1个空白PCB, 将调用者参数添加进PCB, 设置记账数据, 设置新进程就绪态
    * 阻塞原语: 将进程从运行态变为阻塞态. 进程被插入等待事件队列, 同时修改PCB中的相应的表项, 如进程状态和等待队列指针等
    * 唤醒原语: 将进程从阻塞态变为就绪态. 进程从等待队列中移出, 插入就绪队列, 等待调度, 同时修改PCB中的相应表项, 如进程状态等

### 处理机调度

* 调度的概念
    * 调度的基本概念
    * 调度的层次
        * 作业调度(高级调度): 内存和辅存之间的调度
        * 中级调度: 暂时不能运行的进程调至外存等待(挂起)
        * 进程调度(低级调度): 按照策略选取就绪队列的进程运行
    * 3级调度的联系

* 调度的时机, 切换与过程
    * 时机
        * 不能进行
            * 处理中断的过程中
            * 进程在操作系统内核程序临界区中
            * 其他需要完全屏蔽中断的原子操作过程中
        * 应该进行
            * 发生引起调度条件且当前进程无法继续运行下去时(非剥夺调度)
            * 中断处理结束或自陷处理结束后, 返回被中断进程的用户态程序执行现场前, 若置上请求调度标志, 即可马上进行进程调度与切换(剥夺调度)
    * 过程
        * 操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们, 并更新堆栈指针
        * 内核完成从新进程的内核栈中装入新进程的现场信息, 更新当前运行进程空间指针, 重设PC寄存器等相关工作后, 开始运行新的进程

* 进程调度方式
    进程运行过程中会不会被更重要紧迫的进程挤到就绪里面去
    * 非剥夺调度方式
        * 系统开销小
        * 不能用于分时系统和大多数实时系统
    * 剥夺调度方式

* 调度的基本准则
    * CPU利用率
    * 系统吞吐量
    * 周转时间
        * 周转时间 = 作业完成时间 - 作业提交时间 = 作业完成需要的总时间
        * 平均周转时间 = 平均的周转时间
        * 带权周转时间 = 作业周转时间 / 作业实际运行时间
        * 平均带权周转时间 = 平均的带权周转时间
    * 等待时间
    * 相应时间

* 典型的调度算法
    * 先来先服务(FCFS)
        * 算法简单效率低
        * 对长作业有利短作业不利
        * 利于CPU繁忙型作业, 不利于I/O繁忙型作业
    * 短作业优先(SJF)
        * 对长作业不利
        * 没有考虑作业的紧迫程度
        * 根据用户提供的估计执行时间而定, 并不能绝对严格
        * 平均等待时间, 平均周转时间最少
    * 优先级调度算法
        * 非剥夺
        * 剥夺
            * 优先级
                * 系统进程 > 用户进程
                * 交互型进程 > 非交互型进程
                * I/O型进程 > 计算型进程
            * 静态优先级
            * 动态优先级
    * 高相应比优先调度算法
        * 主要用于作业调度
        * $ {响应比R_p} = {等待时间 + 要求服务时间 \over 要求服务时间} $
        * 有利于短作业
        * 先来先服务
    * 时间片轮转调度算法
    * 多级反馈队列调度算法
        * 时间片轮转, 时间片大小随级数增加而减少
        * 加入第n级末尾, 若在该时间片内没有完成则进入第n + 1级末尾

### 进程同步

* 进程同步的概念
    * 临界资源(1次只能供1个进程使用的资源)
        * 进入区
        * 临界区
        * 退出区
        * 剩余区
    * 同步
    * 互斥
        * 空闲让进
        * 忙则等待
        * 有限等待
        * 让权等待

* 实现临界区互斥的基本方法
    * 软件实现方法
        * 单标志法
            * 设置公用整性变量, 指示被允许进入临界区的进程编号
            *   ```
                    // P_i进程          // P_j进程
                    while (turn != 0)   while (turn != 0)   // 进入区
                    critical section    critical section    // 临界区
                    turn = 1            turn = 0            // 退出区
                    remainder section   remainder section   // 剩余区
                ```
        * 双标志法先检查
            * 在进程进入临界区资源前等待临界区资源空闲, 然后设置自己的标志
            *   ```
                    // P_i进程          // P_j进程
                    while (flag[j])     while (flag[i])     // 进入区
                    flag[i] = true      flag[j] = true      // 进入区
                    critical section    critical section    // 临界区
                    flag[i] = false     flag[j] = false     // 退出区
                    remainder section   remainder section   // 剩余区
                ```
            * 可能同时进入临界区
        * 双标志法后检查
            * 进程先设置自己的标志, 然后等待临界区资源空闲
            *   ```
                    // P_i进程          // P_j进程
                    flag[i] = true      flag[j] = true      // 进入区
                    while (flag[j])     while (flag[i])     // 进入区
                    critical section    critical section    // 临界区
                    flag[i] = false     flag[j] = false     // 退出区
                    remainder section   remainder section   // 剩余区
                ```
            * 双方互相谦让
        * Peterson's Algorithm
            * 进程先设置自己的标志和turn, 然后等待临界区资源空闲
            *   ```
                    // P_i进程                      // P_j进程
                    flag[i] = true; turn = i        flag[j] = true; turn = j
                    while (flag[j] && turn === i)   while (flag[i] && turn === j)
                    critical section                critical section
                    flag[i] = false                 flag[i] = false
                    remainder section               remainder section
                ```
    * 硬件实现方法
        * 中断屏蔽方法
        * 硬件指令方法

* 信号量
    * 整型信号量
    * 记录型信号量
    * 利用信号量实现同步:
        ```
            semaphore S = 0
            P1() {
                // ..
                V(S)        // 解放P2
                // ..
            }
            P2() {
                // ..
                // P(S)     // 阻塞P2
                // ..
            }
        ```
    * 利用信号量实现进程互斥:
        ```
            semaphore S = 1
            P1() {
                // ..
                P(S)        // 上锁
                // P1进入临界区
                S = 0
                V(S)        // 解锁
                // ..
            }
            P2() {
                // ..
                P(S)        // 上锁
                // P2进入临界区
                S = 0
                V(S)        // 解锁
                // ..
            }
        ```
    * 利用信号量实现前驱关系:
        ```
            // P1 -> P2; P1 -> P3
            // P2 -> P4; P2 -> P5
            // P3 -> P6
            // P4 -> P6
            // P5 -> P6
            semaphore a0 = a1 = b0 = b1 = c = d = e = 0
            P1() {
                // ..
                V(a0); V(a1)        // 通知P2, P3
            }
            P2() {
                P(a0)               // 等待P1通知
                // ..
                V(b0); V(b1)        // 通知P4, P5
            }
            P3() {
                P(a1)               // 等待P1通知

                // ..
                V(c)                // 通知P6
            }
            P4() {
                P(b0)               // 等待P2通知
                // ..
                V(d)                // 通知P6
            }
            P5() {
                P(b1)               // 等待P2通知
                // ..
                V(e)                // 通知P6
            }
            P6() {
                P(c); P(d); P(e)    // 等待P3, P4, P5通知
                // ..
            }
        ```

* 管程
    * 管程的定义
        * 管程的名称
        * 局部于管程内部的共享结构数据说明
        * 对该数据结构进行操作的1组过程(或函数)
        * 对局部于管程内部的共享数据设置初始值的语句
        *   ``` TypeScript
                // 定义1个名称为"Demo"的管程
                class/* monitor */ Demo {
                    // 定义共享数据结构, 对应系统中的某种共享资源

                    // 对共享数据结构初始化的语句
                    constructor/* initCode */() {
                        // 设定初始资源数 = 5
                        this.s = 5
                    }

                    private s: number | null = null

                    // 申请1个资源
                    public takeAway() {
                        // 对共享数据结构的1系列处理

                        // 可用资源数 - 1
                        this.s--
                    }
                    // 归还1个资源
                    public giveBack() {
                        // 对共享数据结构的1系列处理

                        // 可用资源数 + 1
                        this.s++
                    }
                }
            ```
        * 管程把对共享资源的操作封装起来
        * 每次只允许1个进程进入管程
    *  条件变量

* 经典同步问题
    * 生产者 - 消费者问题:
        ``` TypeScript
            let plateSemaphore: semaphore = 1   // 互斥操作plate
            let appleSemaphore: semaphore = 0   // 同步操作apple
            let orangeSemaphore: semaphore = 0  // 同步操作orange
            dad() {
                while (1) {
                    const apple: Apple = prepareAnApple()
                    P(plateSemaphore)
                    putTheAppleOnThePlate(apple)
                    V(appleSemaphore)
                }
            }
            mom() {
                while (1) {
                    const orange: Orange = prepareAnOrange()
                    P(plateSemaphore)
                    putTheOrangeOnThePlate(orange)
                    V(orangeSemaphore)
                }
            }
            son() {
                while (1) {
                    P(orangeSemaphore)
                    const orange: Orange = takeAnOrangeFromThePlate()
                    V(plateSemaphore)
                    eatTheOrange(orange)
                }
            }
            daughter() {
                while (1) {
                    P(appleSemaphore)
                    const apple: Apple = takeAnAppleFromThePlate()
                    V(plateSemaphore)
                    eatTheApple(apple)
                }
            }
        ```
    * 读者 - 写者问题:
        ``` TypeScript
            let readerCount: number = 0
            let mutex: semaphore = 1    // 互斥操作count
            let rw: semaphore = 1       // 互斥操作file
            writer() {
                while(1) {
                    P(rw)
                    write()
                    V(rw)
                }
            }
            reader() {
                while(1) {
                    P(mutex)
                    if (readerCount === 0) {
                        P(rw)
                    }
                    readerCount++
                    V(mutex)
                    read()
                    P(mutex)
                    readerCount--
                    if (readerCount === 0) {
                        V(rw)
                    }
                    V(mutex)
                }
            }
        ```
        ``` TypeScript
            // 为了不让writer饥饿, 使writer想要时禁止更多的reader
            let readerCount: number = 0
            let mutex: semaphore = 1
            let rw: semaphore = 1
            let w: semaphore = 1
            writer() {
                while(1) {
                    P(w)
                    P(rw)
                    write()
                    V(rw)
                    P(w)
                }
            }
            reader() {
                while(1) {
                    P(w)
                    P(mutex)
                    if (readerCount === 0) {
                        P(rw)
                    }
                    readerCount++
                    V(mutex)
                    V(w)
                    read()
                    P(mutex)
                    readerCount--
                    if (readerCount === 0) {
                        V(rw)
                    }
                    V(mutex)
                }
            }
        ```
    * 哲学家进餐问题:
        ``` TypeScript
            const chopstickSemaphores: semaphore[] = [ 1, 1, 1, 1, 1 ]
            const mutex: semaphore = 1
            Pi() {
                do {
                    P(mutex)    // 拿筷子前获得互斥量
                    P(chopstickSemaphores[i])
                    P(chopstickSemaphores[(i + 1) % 5])
                    V(mutex)    // 释放取筷子的信号量
                    eat()
                    V(chopstickSemaphores[i])
                    V(chopstickSemaphores[(i + 1) % 5])
                    think()
                }
            }
        ```
    * 吸烟者问题

### 死锁

* 死锁的概念
    * 死锁的定义: 多个进程因竞争资源而造成的1种僵局
    * 死锁产生的原因
        * 系统资源的竞争
        * 进程推进顺序非法
        * 死锁产生的必要条件
            * 互斥条件
            * 不剥夺条件
            * 请求并保持条件
            * 循环等待条件

* 死锁的处理策略
    * 死锁的预防
    * 避免死锁
    * 死锁的检测及解除

* 死锁预防: 破坏死锁产生的必要条件

* 死锁避免
    * 系统安全状态
    * 银行家算法
    * 安全性算法举例
    * 银行家算法举例

* 死锁检测和解除
    * 资源分配图
    * 死锁定理

## 内存管理

### 内存管理概念

* 内存管理的基本原理和要求
    * 程序的装入和链接
    * 逻辑地址空间与物理空间
    * 内存保护

* 覆盖与交换
    * 覆盖
    * 交换

* 连续分配管理方式
    * 单一连续分配
    * 固定区连续分配
    * 动态分区分配

* 非连续分配管理方式
    * 基本分页存储管理方式
        * 分页存储的几个基本概念
        * 基本地址变换机构
        * 具有块表的地址变换机构
        * 2级页表
    * 基本分段存储管理方式
        * 分段
        * 段表
        * 地址变换机构
        * 段的共享与保护
    * 段页式管理方式

## 文件管理

### 文件系统基础

* 文件的概念
    * 文件的定义
    * 文件的属性
        * 名称
        * 标识符
        * 类型
        * 位置
        * 大小
        * 保护
        * 时间, 日期, 用户标识
    * 文件的基本操作
        * 创建
        * 读写
        * 重定位(文件寻址): 按某条件搜索目录, 将当前文件位置设为给定值, 并且不会读写文件
        * 删除
        * 截断: 允许文件所有属性不变, 并删除文件内容
    * 文件的打开与关闭

* 文件的逻辑结构
    * 无结构文件(流式文件)
    * 有结构文件(记录式文件)
        * 顺序文件
        * 索引文件
        * 索引顺序文件
        * 直接文件或散列文件

* 目录结构
    * 文件控制块和索引节点
        * 文件控制块(FCB): 存放控制文件需要的各种信息的数据结构, 64B
            * 基本信息: 文件名, 物理位置, 逻辑结构, 物理结构
            * 存取控制信息
            * 使用信息
        * 索引结点
            * 磁盘索引结点
                * 存放在磁盘上的索引节点
                * UNIX中的每个文件都有1个唯一的磁盘索引结点
                * 文件主标识符
                * 文件类型
                * 文件存储权限
                * 文件物理地址
                * 文件长度
                * 文件链接计数
                * 文件存取时间
            * 内存索引结点
                * 磁盘索引结点
                * 索引结点编号
                * 状态
                * 访问计数
                * 逻辑设备号
                * 链接指针
    * 目录结构
        * 功能
            * 搜索
            * 创建文件
            * 删除文件
            * 显示目录
            * 修改目录
        * 结构种类
            * 单级目录结构
            * 2级目录结构: 用户名 -> 文件名
            * 多级目录结构
            * 无环图目录结构: 多级目录结构的文件共享

* 文件共享
    * 基于索引结点的共享方式(硬链接)
    * 利用符号链实现文件共享(软链接)

* 文件保护
    * 基于访问类型
    * 基于访问控制
        * 拥有者: 创建文件的用户
        * 组: 一组需要共享文件且具有类似访问的用户
        * 其他: 系统内所有其他用户
    * 基于口令和密码
        * 口令: 直接存放在系统内部
        * 密码: 对文件进行加密
        * 防止文件被窃取, 不能控制用户对文件的访问类型

### 文件系统实现

* 文件系统层次结构
    * 用户调用接口: 为用户提供与文件及目录有关的调用(增删改查)
    * 文件目录系统: 管理文件目录
    * 存取控制验证模块: 用户的访问要求与FCB中指示的访问控制权限进行比较, 确认访问的合法性
    * 逻辑文件系统与文件信息缓冲区:
        根据文件的逻辑结构将用户要读写的逻辑记录转换成文件逻辑结构内的相应块号
    * 物理文件系统: 把逻辑记录所在的相对块号转换成实际的物理地址
    * 辅助分配模块: 管理辅存空间
    * 设备管理程序模块: 管理设备

* 目录实现
    * 线性列表
    * 哈希表

* 文件实现
    * 文件分配方式
        * 连续分配
        * 链接分配: 磁盘小块都有next指针, 目录指向头磁盘小块
        * 索引分配: 目录指向指定文件的文件索引表, 文件索引表指向每个磁盘小块
