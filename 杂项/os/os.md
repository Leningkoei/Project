# OS

## 操作系统的基本概念

### 操作系统的概念

* 操作系统的特征
    * 并发(最基本)
    * 共享(最基本)
        * 互斥访问方式
        * 同时访问方式
    * 虚拟
    * 异步

* 操作系统的目标和功能
    * 操作系统作为计算机系统资源的管理者
        * 处理机管理
        * 存储器管理
        * 文件管理
        * 设备管理
    * 操作系统作为用户与计算机硬件系统之间的接口
        * 命令接口
        * 程序接口
    * 操作系统用作扩充机器

* ---

* 操作系统提供给编程人员的接口是<u>系统调用</u>

* <u>顺序性</u>不属于多道程序设计的基本特征

* 说明库函数与系统调用的区别和联系
    * 库函数
        * 库函数是语言或应用程序的一部分, 可以运行在用户空间中
    * 系统调用
        * 系统调用是操作系统的一部分, 是内核为用户提供的程序接口, 运行在内核空间中
    * 联系
        * 许多库函数都会使用系统调用来实现功能
        * 未使用系统调用的库函数, 其执行效率通常比使用了系统调用的库函数高, 因为在使用系统调用时需要进行上下文的切换以及状态的转换(由用户态转向核心态)

### 操作系统的发展与分类

* 手工操作阶段

* 批处理阶段
    * 单道批处理系统
        * 自动性
        * 顺序性
        * 单道性
    * 多道批处理系统
        * 多道
        * 宏观上并行
        * 微观上串行
        * [x] 资源利用率高
        * [x] 系统吞吐量大
        * [ ] 用户响应时间长
        * [ ] 不提供人机交互能力
* 分时操作系统
    * 同时性
    * 交互性
    * 独立性
    * 及时性

* 实时操作系统
    * 硬实时系统
    * 软实时系统

* 网络操作系统和分布式计算机系统

* 个人计算机操作系统

* ---

* 实时系统的进程调度, 通常采用<u>抢占式的优先级高者优先</u>算法

* 分时系统追求的目标是<u>比较快速响应用户</u>

* 批处理操作系统, 分时操作系统, 实时操作系统各有什么特点
    * 批处理操作系统的用户脱机使用计算机, 作业时成批处理的, 系统内多道程序并发执行, 交互能力差
    * 分时操作系统可让多个用户同时使用计算机, 人机交互性较强, 具有每个用户独立使用计算机的独占性, 系统响应及时
    * 实时操作系统能对控制对象做出及时反应, 可靠性高, 响应及时, 但资源利用率低

### 操作系统的运行环境

* 操作系统的运行机制
    * 时钟管理
    * 中断机制
    * 原语
        * 最底层, 最接近硬件
        * 原子性
        * 运行时间短, 调用频繁
    * 系统控制的数据结构及处理
        * 进程管理
        * 存储器管理
        * 设备管理

* 中断和异常的概念
    * 用户态转向核心态的门
    * 内中断和外中断的联系与区别
        * 内中断(异常)
            * 自愿中断
                * 指令中断
            * 强迫中断
                * 故障中断
                * 软件中断
        * 外中断(中断)
            * 强迫中断
                * 外设请求
                * 人的干预
    * 中断处理的过程:
        关中断 -> 保存断点 -> 引出中断服务程序 -> 保存现场和屏蔽字 ->
        开中断 -> 执行中断服务程序 -> 关中断 -> 恢复现场和屏蔽字 -> 开中断, 中断返回

* 系统调用
    * 类别
        * 设备管理
        * 文件管理
        * 进程控制
        * 进程通信
        * 内存管理
    * 用户态转向核心态的过程:
        用户进程执行 -> 调用系统调用 -(陷阱)> 执行系统调用 -(返回)>从系统调用返回
    * 用户态转向核心态的例子
        * 用户程序要求操作系统的服务
        * 发生1次中断
        * 用户程序中产生了1个错误状态
        * 用户程序中企图执行1条特权指令
        * 从核心态转向用户态由1条指令实现, 这条指令也是特权指令, 一般是中断返回指令
    * 访管指令: 程序的运行从用户态转到核心态时会用到

* ---

* 处理器为什么要区分核心态和用户态2种操作方式? 在什么情况下进行2种方式的切换?
    * 区分执行态的目的是保护系统程序
    * 用户态到核心态的转换发生在中断产生时
    * 核心态到用户态的转化发生在中断返回程序时

### 操作系统的体系结构

* 大内核
    * [x] 高性能
    * [ ] 内核代码庞大
    * [ ] 结构混乱
    * [ ] 难以维护

* 微内核
    * [x] 内核功能少
    * [x] 结构清晰
    * [x] 方便维护
    * [ ] 需要频繁地在核心态和用户态之间切换, 性能低

## 进程管理

### 进程与线程

* 进程的概念和特征
    * 进程的概念
        * 进程是程序的1次执行过程
        * 进程是1个程序及其数据在处理机上顺序执行时所发生的活动
        * 进程是具有独立功能的程序在1个数据集合上运行的过程, 它是系统进行资源分配和调度的1个独立单位
    * 进程的特征
        * 动态性
        * 并发性
        * 独立性
        * 异步性
        * 结构性

* 进程的状态与转换
    * 5种进程状态
        * 运行态
        * 就绪态
        * 阻塞态
        * 创建态
        * 结束态
    * 5种进程状态的转换
        * <image src="./images/5种进程状态的转换.jpg" />
        * 就绪态 -> 运行态: 就绪态进程被调度获得处理机资源
        * 运行态 -> 就绪态:
            运行态进程时间片用完让出处理机,
            可剥夺系统中有更高优先级进程进入
        * 运行态 -> 阻塞态: 运行态进程请求资源或等待某1事件的发生
        * 阻塞态 -> 就绪态: 阻塞态进程等待的事件到来

* 进程控制
    * 进程的创建
        * 为新进程分配1个唯一的进程标识号, 并申请1个空白的PCB
        * 为进程分配资源
        * 初始化PCB
        * 进入就绪队列
    * 进程的终止
        * 触发条件
            * 正常结束
            * 异常结束
            * 外界干预
        * 过程(撤销原语)
            * 根据被终止进程的标识符, 检索PCB, 从中读出该进程的状态
            * 若被终止进程处于执行状态, 立即终止该进程的执行, 将处理机资源分配给其他进程
            * 若该进程还有子孙进程, 则终止其所有子孙进程
            * 归还该进程的所有资源给父进程或操作系统
            * 删除PCB
    * 进程的阻塞和唤醒
        * 阻塞过程(阻塞原语)
            * 找到进程号对应PCB
            * 若该进程为运行态, 则保护该现场, 转为阻塞态
            * 把该PCB插入相应事件的等待队列, 将处理机资源调度给其他就绪进程
        * 唤醒过程(唤醒原语)
            * 在该事件的等待队列中找到相应进程的PCB
            * 将其从等待队列中移出, 转为就绪态
            * 把PCB插入就绪队列, 等待调度程序调度
    * 进程切换: 处理机从1个进程的运行转到另1个进程上运行
        * 保存处理机上下文, 包括程序计数器和其他寄存器
        * 更新PCB信息
        * 把进程的PCB移入相应的队列
        * 选择另1个进程执行, 并更新其PCB
        * 更新内存管理的数据结构
        * 恢复处理机上下文

* 进程的组织(进程的组成)
    * 进程控制块(PCB)
        * 进程描述信息
        * 进程控制和管理信息
        * 资源分配清单
        * 处理机相关信息
    * 程序段(正文段)
        * 2进制代码和常量
    * 数据段
        * 数据堆段
            * 动态分配的存储区
        * 数据栈段
            * 临时使用的变量

* 进程的通信
    * 共享存储
    * 消息传递: 发送消息原语, 传递消息原语
        * 直接通信方式
        * 间接通信方式
    * 管道通信: pipe文件连接2个进程

* 线程概念和多线程模型
    * 线程的基本概念
        * 轻量级的进程
        * 基本的CPU执行单元, 程序执行流的最小单元
        * 线程ID, 程序计数器, 寄存器集合, 堆栈
        * 进程中的1个实体, 被系统独立调度和分派的基本单位
        * 不拥有系统资源, 与其他同属1个进程的线程s共享进程资源
        * 就绪, 阻塞, 运行3中状态
        * 线程作为CPU资源的分配单元, 进程作为其他资源的分配单元
    * 线程与进程的比较
        * 调度
        * 拥有资源
        * 并发性
        * 系统开销
        * 地址空间和其他资源
        * 通信方面
    * 线程的属性
        * 轻量级的实体, 不拥有系统资源, 有唯一标识符和线程控制块, 线程控制块记录线程执行的寄存器, 栈等现场状态
        * 不同的线程可以执行相同的程序
        * 同一进程中的各个线程共享该进程所拥有的资源
        * 线程是处理机的独立调度单位, 多个线程可以并发执行
    * 线程的实现方式
        * 用户级线程
        * 内核级线程
    * 多线程模型
        * 多对1模型
        * 1对1模型
        * 多对多模型

* ---

* 进程和程序之间可以形成1对1, 1对多, 多对1, 多对多的关系, 请分别举例说明在什么情况下会形成这样的关系
    * 1对1: 执行1条命令或运行1个应用程序时
    * 1对多: 进程在执行过程中可以加载执行不同的应用程序
    * 多对1: 以不同参数或数据多次执行同1个应用程序
    * 多对多: 并发地执行不同的应用程序

* 父进程创建子进程和主程序调用子程序有何不同?
    * 父进程创建子进程后与子进程同时执行(并发)
    * 主程序调用子程序后, 主程序暂时停在调用点, 子程序开始执行, 直到子程序返回, 主程序才继续执行

* 为什么进程之间通信必须借助于操作系统内核功能? 简单说明进程通信的几种主要方式
    * 每个进程都有自己独立的地址空间, 在操作系统和硬件的地址保护机制下, 进程无法访问其他进程的地址空间, 所以必须借助操作系统的系统调用函数实现进程之间的通信
    * 共享内存区, 消息传递, 管道系统, 共享文件

* 什么是多线程? 多线程与多任务有什么区别?
    * 多线程是指在1个程序中可以定义多个线程并同时运行它们, 每个线程可以执行不同的任务
    * 多任务是针对操作系统而言的, 代表操作系统可以同时执行的程序个数
    * 多线程是针对1个程序而言的, 代表1个程序可以同时执行的线程个数, 而每个线程可以完成不同的任务

* 现代操作系统一般都提供多进程(或称多任务)运行环境, 回答以下问题:
    为支持多进程的并发执行, 系统必须建立哪些关于进程的数据结构?
    为支持进程状态的变迁, 系统至少应提供哪些进程控制原语?
    执行每个进程控制原语时, 进程状态发生什么变化? 相应的数据结构发生什么变化?

    * 进程控制块(PCB)
    * 创建新进程原语: 从PCB集合中申请1个空白PCB, 将调用者参数添加进PCB, 设置记账数据, 设置新进程就绪态
    * 阻塞原语: 将进程从运行态变为阻塞态. 进程被插入等待事件队列, 同时修改PCB中的相应的表项, 如进程状态和等待队列指针等
    * 唤醒原语: 将进程从阻塞态变为就绪态. 进程从等待队列中移出, 插入就绪队列, 等待调度, 同时修改PCB中的相应表项, 如进程状态等

### 处理机调度

* 调度的概念
    * 调度的基本概念
    * 调度的层次
        * 作业调度(高级调度): 内存和辅存之间的调度
        * 中级调度: 暂时不能运行的进程调至外存等待(挂起)
        * 进程调度(低级调度): 按照策略选取就绪队列的进程运行
    * 3级调度的联系

* 调度的时机, 切换与过程
    * 时机
        * 不能进行
            * 处理中断的过程中
            * 进程在操作系统内核程序临界区中
            * 其他需要完全屏蔽中断的原子操作过程中
        * 应该进行
            * 发生引起调度条件且当前进程无法继续运行下去时(非剥夺调度)
            * 中断处理结束或自陷处理结束后, 返回被中断进程的用户态程序执行现场前, 若置上请求调度标志, 即可马上进行进程调度与切换(剥夺调度)
    * 过程
        * 操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们, 并更新堆栈指针
        * 内核完成从新进程的内核栈中装入新进程的现场信息, 更新当前运行进程空间指针, 重设PC寄存器等相关工作后, 开始运行新的进程

* 进程调度方式
    进程运行过程中会不会被更重要紧迫的进程挤到就绪里面去
    * 非剥夺调度方式
        * 系统开销小
        * 不能用于分时系统和大多数实时系统
    * 剥夺调度方式

* 调度的基本准则
    * CPU利用率
    * 系统吞吐量
    * 周转时间
        * 周转时间 = 作业完成时间 - 作业提交时间 = 作业完成需要的总时间
        * 平均周转时间 = 平均的周转时间
        * 带权周转时间 = 作业周转时间 / 作业实际运行时间
        * 平均带权周转时间 = 平均的带权周转时间
    * 等待时间
    * 相应时间

* 典型的调度算法
    * 先来先服务(FCFS)
        * 算法简单效率低
        * 对长作业有利短作业不利
        * 利于CPU繁忙型作业, 不利于I/O繁忙型作业
    * 短作业优先(SJF)
        * 对长作业不利
        * 没有考虑作业的紧迫程度
        * 根据用户提供的估计执行时间而定, 并不能绝对严格
        * 平均等待时间, 平均周转时间最少
    * 优先级调度算法
        * 非剥夺
        * 剥夺
            * 优先级
                * 系统进程 > 用户进程
                * 交互型进程 > 非交互型进程
                * I/O型进程 > 计算型进程
            * 静态优先级
            * 动态优先级
    * 高相应比优先调度算法
        * 主要用于作业调度
        * $ {响应比R_p} = {等待时间 + 要求服务时间 \over 要求服务时间} $
        * 有利于短作业
        * 先来先服务
    * 时间片轮转调度算法
    * 多级反馈队列调度算法
        * 时间片轮转, 时间片大小随级数增加而减少
        * 加入第n级末尾, 若在该时间片内没有完成则进入第n + 1级末尾

### 进程同步

### 死锁
