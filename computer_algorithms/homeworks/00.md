#   作业

##  1 - 4
***
设新机器用同一算法在t s内能解输入规模为$n_1$的问题;

### (1)
$${3 * 2 ^ {n_1} \over 64} = {3 * 2 ^ {n}}$$
$${2 ^ {n_1}} = {2 ^ {n + 6}}$$
<font color="green">$${n_1} = {n + 6}$$</font>

### (2)
$${n_1 ^ 2 \over 64} = {n ^ 2}$$
<font color="green">$${n_1} = {8n}$$</font>

### (3)
<center><font color="green">时间复杂度与问题规模无关;</font></center>

##  1 - 5
***
设ABC公司的计算机在1 h内能解输入规模为$n_0$的问题, XYZ公司的计算机在1 h内能解输入规模为$n_1$的问题;

### 算法计算复杂性: $n$
$${{n_1} \over {100}} = {n_0}$$
<font color="green">$${n_1} = {100n_0}$$</font>

### 算法计算复杂性: $n ^ 2$
$${{n_1 ^ 2} \over {100}} = {n_0 ^ 2}$$
<font color="green">$${n_1} = {10n_0}$$</font>

### 算法计算复杂性: $n ^ 3$
$${{n_1 ^ 3} \over {100}} = {n_0 ^ 3}$$
<font color="green">$${n_1} = {\sqrt[3]{100}n_0}$$</font>

### 算法计算复杂性: $n!$
$${{n_1!} \over 100} = {n_0!}$$
<center><font color="green">不会;</font></center>

##  2 - 3
***
```binary_search.mjs```
``` javascript []
export { binarySearch };
/**
 * @param {number[]} nums 目标数组;
 * @param {number} target 目标值;
 * @returns {number[]}
 */
function binarySearch(nums, target) {
    let left = 0;
    let right = nums.length;
    while (left < right) {
        const mid = left + (right - left >>> 1);
        if (nums[mid] === target) {
            return [ mid, mid ];
        } else if (nums[mid] < target) {
            left = mid + 1;
        } else if (nums[mid] > target) {
            right = mid;
        }
    }
    return [ left, left + 1 ];
}

```

##  2 - 4
***
仅看了1下Page18的例子;
不太懂...
书中Page18, 因为整数过大以至于使用字符串表示, 那么给出的方法中:
$$... * 2 ^ n$$
认为是位移操作, 但是因为该$...$过大, 没办法直接进行位运算, 那么就应该被视作是大数乘法而不是简单的位移操作;<br>
总之是每1步操作都需要模拟;<br>
模拟无符号加法还好写点, 模拟减法就不会了阿;<br>
而且在x, y中仅有1个length < 2的情况不会写阿;<br>
不过这个这么复杂的几坨效率真的有分割31位字符串效率高吗<br>
我暂且蒙古;
``` javascript []
export { bigIntegersDot };
/**
 * @param {string} x
 * @param {string} y
 * @returns {string}
 */
function bigIntegersDot(x, y) {
    if (x.length < 2 && y.length < 2) {
        return parseInt(x) * parseInt(y);
    } else if (x.length < 2 && y.length >= 2) {
        // TODO;
    } else if (x.length >= 2 && y.length < 2) {
        // TODO;
    }
    const xMid = x.length >>> 1;
    const yMid = y.length >>> 1;
    const count = x.length + y.length;
    const help0 = "1";
    while (count--) {
        help0 += "0";
    }
    const help1 = "1";
    for (count = x.length + y.length >>> 1; count; count--) {
        help1 += "0";
    }
    const a = x.substring(0, xMid + 1);
    const b = x.substring(xMid + 1, x.length);
    const c = y.substring(0, yMid + 1);
    const d = y.substring(yMid + 1, y.length);
    const ac = bigIntegersDot(a, c);
    const bd = bigIntegersDot(b, d);
    const md = bigIntegersDot(a - b, d - c);
    const subAB = bigIntegersSub(a, b);
    const subDC = bigIntegersSub(d, c);
    const subABsubDC = bigIntegersDot(subAB, subDC);
    const rightMoveLengthAC = bigIntegersDot(ac, help0);
    const sumACBD = bigIntegersSum(ac, bd);
    const sumSubABSubDCsumACBD = bigIntegersSum(subABsubDC, sumACBD);
    const rightMoveIt = bigIntegersDot(sumSubABSubDCsumACBD, help1);
    const FUCK = bigIntegersSum(rightMoveLengthAC, rightMoveIt);
    return bigIntegersSum(FUCK, md);
}
function bigIntegersSum(x, y) {
    if (x.length < y.length) {
        [ x, y ] = [ y, x ];
    }
    let bit = y.length;
    let carry = 0;
    let result = "";
    while (bit--) {
        const sum = parseInt(x[bit]) + parseInt(y[bit]) + carry;
        carry = sum >= 10 ? 1 : 0;
        result += (sum >= 10 ? sum - 10 : sum).toString();
    }
    bit = x.length - bit;
    while (bit--) {
        const sum = parseInt(x[bit]) + carry;
        carry = sum >= 10 ? 1 : 0;
        result += (sum >= 10 ? sum - 10 : sum).toString();
    }
    result += carry;
    return result.split("").reverse().join("");
}
function bigIntegersSub(x, y) {
    // TODO;
}

```
