readme
    折叠 ctrl + k + ctrl + 0
    展开 ctrl + k + ctrl + j

1   C++的初步认识
    1   从C到C++

    2   最简单的C++程序
        例1.1
        例1.2
        例1.3
        例1.4

    3   C++对C的扩充
        1   C++的输入输出
            1   用cout进行输出
            2   用cin进行输入
                例1.5

        2   用const定义常变量
            const float PI = 3.14 不能改变

        3   函数原型声明

        4   函数的重载
            一个函数名多用
            例1.6
            例1.7

        5   函数模板
            例1.8

        6   有默认参数的函数

        7   变量的引用
            1   引用的概念

            2   引用的简单使用
                例1.9

            3   关于引用的简单说明

            4   将引用作为函数参数
                例1.10
                例1.11
                例1.12

            5   对引用的进一步说明

        8   内置函数
            例1.13

        9   作用域运算符
            例1.14

        10  字符串变量
            1   定义字符串变量
            2   对字符串变量赋值
            3   字符串变量的输入输出
            4   字符串变量的运算
            5   字符串数组
                例1.15

        11  动态分配|撤销内存的运算符new和delete
            例1.16

        12  C++对C功能扩展的小结

    4   C++程序的编写和实现

    5   关于C++上机实践

2   类和对象的特征
    1   面向对象程序设计方法概述
        1   什么是面向对象的程序设计
            1   对象
                静态特征: 属性 <- 数据
                动态特征: 行为 <- 函数
                消息
                任何一个对象都应当具有属性和行为这两个要素
                对象应能根据外界给的消息进行相应的操作
                一个对象一般是由一组属性和一组行为构成的
                函数是用来对数据进行操作的, 以便实现某些功能
                调用某一个对象中的函数, 就相当于向该对象传送一个消息, 要求该对象实现某一行为

            2   封装与信息隐蔽
                把对象的内部实现和外部行为分隔开来
                C++的对象中的函数名(指公用函数)就是对象的对外接口, 外界可以通过函数名来调用这些函数来实现某些行为

            3   抽象
                抽象的作用是表示同一类事物的本质
                类是对象的抽象, 对象是类的具体表现形式

            4   继承与重用

            5   多态性
                由继承而产生的相关却不同的类, 其对象对同一消息会做出不同的相应

        2   面向对象程序设计的特点
            设计所需的各种类和对象
            考虑怎样向有关对象发送消息

        3   类和对象的作用

        4   面向对象的软件开发

    2   类的声明和对象的定义
        1   类和对象的关系
            类是对象的抽象, 对象是类的具体实例

        2   声明类的类型
            class Name
            {
            private:
                私有的数据和成员函数;
            public:
                公有的数据和成员函数;
            };

        3   定义对象的方法

        4   类和结构体的异同

    3   类的成员函数
        1   成员函数的性质
            将需要被外界调用的成员函数指定为public, 它们是类的对外接口

        2   在类外定义成员函数
            type Class::function() {}

        3   内置成员函数(inline成员函数)

        4   成员函数的存储方式

    4   对象成员的引用
        1   通过对象名和成员运算符访问对象中的成员
            object.public

        2   通过指向对象的指针访问对象中的成员
            p = &object;
            p->public == (*p).public == object.public

        3   通过对象的引用(别名)来访问对象中的成员
            &a = object;
            a.public == object.public

    5   类和对象的简单应用举例
        例2.1
        例2.2
        例2.3
        例2.4

    6   类的封装性和信息隐藏
        1   (公用)接口与(私有)实现的分离
            只要类的接口没有改变, 对实现的修改不会引起程序的其他部分的修改

        2   类声明和成员函数定义的分离

        3   面向对象程序设计中的几个名词

3   怎样使用类和对象
    1   利用构造函数对类对象进行初始化
        1   对象的初始化

        2   利用构造函数实现数据成员的初始化
            构造函数时一种特殊的成员函数, 与其他成员函数不同, 不需要用户来调用它, 而是在建立对象时自动执行
            构造函数的名字必须与类名同名
            例3.1
            类外定义构造函数
                Class::Class()
                {
                    member...;
                }

        3   带参数的构造函数
            例3.2

        4   用参数初始化表对输出成员初始化

        5   构造函数的重载
            例3.3

        6   使用默认参数的构造函数
            例3.4

    2   利用析构函数进行清理工作
        例3.5

    3   调用构造函数和析构函数的顺序
        堆栈顺序

    4   对象数组
        对象数组中的每一个元素都是同类的对象

    5   对象指针
        1   指向对象的指针

        2   指向对象成员的指针
            1   指向对象数据成员的指针
                p = &object.public;
                *p == object.public

            2   指向对象成员函数的指针
                type (Class:: *p)();
                p = &Class::public;
                p == public

            例3.7

        3   指向对象的this指针
            *this == object
            this->public == object.public == public

    6   共用数据的保护
        1   常对象
            Class const object();
            通过该对象只能调用它的常成员函数

        2   常对象成员
            1   常数据成员

            2   常成员函数
                如果将成员函数声明为常成员函数, 则只能引用本类中的数据成员, 而不能修改它们
                常成员函数不能调用非const成员函数
                Class function() const;

        3   指向对象的常指针
            指向对象的常指针变量的值不能改变, 即始终指向同一个对象, 但可以改变其所指向对象的值
            Class* const p;
            p = &object;

        4   指向常变量的指针变量
            表示指针变量p指向的变量是常变量, 不能通过p来修改其值
            const type* p;
            如果一个变量已经被声明为常变量, 只能用指向常变量的指针指向它
            指向常变量的指针也可以指向一般变量, 此时不能通过此指向常变量的指针来修改此变量的值
            当希望在调用函数时对象的数据成员不被修改, 就应当把函数的形参定义为指向常变量的指针

        5   对象的常引用
            type function(const Class &p);

        6   const型数据的小结

    7   对象的动态建立和释放

    8   对象的赋值和复制
        1   对象的赋值
            对对象中的数据成员赋值
            object2 = object1;
            例3.9

        2   对象的复制
            Class object2(object1);

    9   静态成员
        1   静态数据成员
            静态数据成员 == 类中的全局变量
            static type member;
            只能在类体外进行初始化
            type Class::member = ...;
            在类外使用类名进行调用
            Class::member
            例3.10

        2   静态成员函数
            static type function();
            在类外使用类名进行调用
            Class::member();
            静态成员函数不能访问本类中的非静态成员
            例3.11

    10  友元
        1   友元函数
            友元函数可以访问本类中的私有成员
            在本类以外的其他地方定义了一个函数, 在类体中用friend对其进行声明
            1   将普通函数声明为友元函数
                例3.12

            2   友元成员函数
                类的提前引用声明
                例3.13
                在多文件整合编译的条件下注意编译原理顺序

        2   友元类
            友元类中所有的函数都可以访问此类中的所有成员

    11  类模板
        template <class newtype>;
        class Class{};

        template <class newtype>;
        type Class <newtype>::function(){}

        Class <type> object();

        例3.14

4   对运算符进行重载
    1   为什么要对运算符重载
        例4.1

    2   对运算符重载的方法
        重载运算符函数
            type operatoroperator(){}
            object3 = object1 operator object2; == object3 = object1.operatoroperator(object2);
        例4.2

    3   重载运算符的规则
        1   只能对已有的运算符进行重载
        2   存在不能重载的运算符
        3   不能改变运算符运算对象的个数
        4   不能改变运算符的优先级
        5   不能改变运算符的结合性
        6   不能有默认的参数
        7   至少有一个时类对象(即不能全是标准type)

    4   运算符重载函数作为类成员函数和友元函数
        例4.3
        注意运算符重载函数的重载

    5   重载二元运算符
        例4.4

    6   重载一元运算符
        例4.5
        例4.6

    7   重载流插入运算符和流提取运算符
        istream& operator>>(istream&, Class&);
        ostream& operator<<(ostream&, Class&);
        只能作为友元函数
        1   重载流插入运算符<<
            例4.7

        2   重载流提取运算符>>
            例4.8

    8   有关运算符重载的归纳

    9   不同类型数据间的转换
        1   标准类型数据间的转换
            type(num)

        2   用转换构造函数进行不同类型数据的转换
            Class object(num);
            Class(num);

        3   类型转换函数
            operator type() {}
            函数没有函数类型和参数
            只能作为成员函数
            例4.9

        例4.10

5   继承与派生
    1   什么是继承与派生
        派生类是基类的具体化, 基类是派生类的抽象

    2   派生类的声明方式
        class Derived: [type] Basic {}

    3   派生类的构成
        1   从基类接收全部的成员

        2   调整从基类接收的成员
            用同名新成员覆盖接收的成员

        3   增加的成员

    4   派生类成员的访问属性
        1   type == public
            public -> public
            private -> x
            protected -> protected
            例5.1

        2   type == private
            public -> private
            private -> x
            protected -> private
            例5.2

        3   type == protected
            protected: 不能被外界引用, 可以被派生类引用
            public -> protected
            private -> x
            protected -> protected
            例5.3

        4   多级派生时的访问属性

    5   派生类的构造函数和析构函数
        1   简单的派生类的构造函数
            Derived();
            Derived::Derived() :Basic() {}
            例5.5

        2   有子对象的派生类的构造函数
            子对象: 在派生类里定义的上级类的对象
            例5.6

        3   多层派生时的构造函数
            例5.7

        4   派生类构造函数的特殊形式
            1   派生类无构造函数
                Derived::Derived() : Basic {NULL}

            2   基类无构造函数
                Derived::Derived() {}

        5   派生类的析构函数
            在对象撤销之前, 进行必要的清理工作
            派生类需要定义自己的析构函数

    6   多重继承
        一个派生类有复数基类
        1   声明多重继承的方法
            class Derived : types Basics {}

        2   多重继承派生类的构造函数
            Derived();
            Derived::Derived() : Basics() {}
            例5.8

        3   多重继承引起的二义性问题
            1   Basic -> Deriveds
                ... Basic::member ...

            2   Basic -> Deriveds => DerivedII
                ... Derived::member ...

        4   虚基类
            1   虚基类的作用
                Basic -> Deriveds => DerivedII
                Derived::member == Basic::member

            2   虚基类的初始化
                class Derived : virtual type Basic {}
                二级派生类的构造函数
                    class DerivedII();
                    DerivedII::DerivedII() : Basics(), Deriveds() {}

            3   虚基类的简单应用举例
                例5.9

    7   基类与派生类的转换
        1   用派生类对象对基类对象赋值
            基类 -> 派生类, 派生类 -> 同级派生类 x

        2   派生类对象可以替代基类对象向基类对象的引用进行赋值或初始化
            Basic& p = (Derived::)object;

        3   如果函数的参数时基类对象或基类对象的引用, 相应的实参可以用子类对象

        4   派生类对象的地址可以赋给指向基类对象的指针变量, 指向基类对象的指针变量可以用来指向派生类对象
            例5.9
            通过指向基类对象的指针, 只能访问派生类中的基类成员, 而不能访问派生类增加的基类成员

    8   继承与组合
        Class object => member

    9 继承在软件开发中的重要意义

6    多态性与虚函数
    1   什么是多态性
        每个对象用不同方法响应一个消息
        静态多态性: 函数的重载
        动态多态性: 虚函数

    2   一个典型的例子
        例6.1

    3   利用虚函数实现动态多态性
        1   虚函数的作用
            允许在派生类中重新定义与基类同名的函数, 并且可以通过基类指针或引用来访问基类和派生类中的同名函数
